# `pure-noise` benchmarks

Benchmarks were performed on an i9-13900K on a fedora 40 distrobox with LLVM 15 on the PATH.

## Notes

- Benchmarks are run by mapping a noise function over a 1 million element unboxed array of indices.
  - This creates maybe ~1-2ms of overhead.
  - Using index tuples is intended to increase the probability that we hit as many possible code paths in the noise implementation. Some noise functions may skip certain computations when specific conditions are met relative to the input.
- Memory allocation should be constant.
  - Float ~= 4.0MB (4 bytes \* 1_000_000 elements)
  - Double ~= 8.0MB (8 bytes \* 1_000_000 elements)
- Benchmarks that use 'massiv' demonstrate thread-level parallelism, and are the intended path of use for most purposes as of now.

## `pure-noise` Results (LLVM)

Measured by values per second (vps) generated by the noise functions. These results are from benchmarks run with the `-fllvm` backend.

### 2D (Single-Thread)

| name          | Float (vps) | Double (vps) |
| :------------ | :---------- | :----------- |
| perlin2       | 149_722_134 | 160_472_382  |
| value2        | 149_431_304 | 156_907_047  |
| openSimplex2  | 73_308_107  | 74_525_592   |
| valueCubic2   | 59_537_847  | 51_348_431   |
| superSimplex2 | 49_496_504  | 50_508_297   |
| cellular2     | 34_709_237  | 31_918_303   |

### 3D (Single-Thread)

| name        | Float (vps) | Double (vps) |
| :---------- | :---------- | :----------- |
| value3      | 81_698_430  | 84_838_547   |
| perlin3     | 61_666_168  | 72_186_243   |
| valueCubic3 | 16_774_906  | 12_696_197   |

### 2D Parallel (`massiv`)

| name          | Float (vps)   | Double (vps)  |
| :------------ | :------------ | :------------ |
| value2        | 2_237_841_881 | 1_945_933_956 |
| perlin2       | 1_698_650_419 | 1_380_889_459 |
| openSimplex2  | 1_064_963_183 | 941_187_265   |
| valueCubic2   | 1_049_935_068 | 717_173_337   |
| superSimplex2 | 823_957_363   | 784_302_234   |
| cellular2     | 611_138_830   | 576_697_780   |

## Reproducibility

There are two hacky scripts in this folder that can be used to bench with the exact arguments I've used.

- `results/collect-bench.sh` -- hacky script to document the parameters used to create benchmark results
- `results/vps.py` -- _very_ hacky script to calculate values/second numbers from `tasty-bench` csv output

## Comparison with FastNoiseLite

To provide an accurate, hardware-equivalent comparison, benchmarks for [FastNoiseLite (FNL)](https://github.com/Auburn/FastNoiseLite) were run locally on the same machine using the `NoiseBenchmarking` tool and compared against this library's results (compiled with the LLVM backend).

### Benchmark Methodology

Two benchmark approaches are used:

1. **Standard benchmarks** (1M values): Use fractional coordinates with random offsets to exercise all code paths and avoid potential fast-path optimizations at integer boundaries
2. **FNL-comparison benchmarks** (262K values): Use integer-aligned grid coordinates matching FNL's exact methodology for direct apples-to-apples comparison

### Single-Thread Performance Comparison

**Direct comparison (integer-aligned grid, 512×512 for 2D, 64³ for 3D):**

| Noise Type          | pure-noise (Float) | FastNoiseLite | % of FNL |
| :------------------ | :----------------- | :------------ | :------- |
| **Value 2D**        | 146_381_889        | 187_033_000   | 78.3%    |
| **Perlin 2D**       | 146_141_611        | 170_921_000   | 85.5%    |
| **OpenSimplex2 2D** | 107_777_568        | 125_224_000   | 86.1%    |
| **SuperSimplex 2D** | 90_680_451         | 98_274_900    | 92.3%    |
| **ValueCubic 2D**   | 58_701_914         | 70_041_600    | 83.8%    |
| **Cellular 2D**     | 58_785_230         | 68_284_900    | 86.1%    |
| **Value 3D**        | 80_298_842         | 111_514_000   | 72.0%    |
| **Perlin 3D**       | 60_859_623         | 90_821_200    | 67.0%    |
| **ValueCubic 3D**   | 16_951_154         | 23_361_200    | 72.6%    |

Pure Haskell with LLVM achieves **67-92% of C++ performance** in single-threaded scenarios, with simpler noise types (Perlin, OpenSimplex2, SuperSimplex) reaching 85-92% of FNL's speed.

### Coordinate Pattern Impact

The choice of coordinate pattern affects performance differently across algorithms:

- **Perlin/Value/ValueCubic**: Integer coordinates are slightly slower (-1 to -2%) than fractional
- **OpenSimplex2/SuperSimplex**: Integer coordinates are significantly faster (+47% to +83%) than fractional, likely due to improved cache locality and branch prediction with regular grid patterns

### Parallel Performance

The `massiv`-based parallel benchmarks demonstrate significantly higher throughput by leveraging multiple cores. This is the intended path for high-performance, large-scale noise generation with this library.

For example, the parallel `massiv` 2D Perlin benchmark achieves **~1.7 billion values/sec**, over 10× the single-threaded FNL result and 12× the single-threaded pure-noise result.
