# `pure-noise` benchmarks

Benchmarks were performed on an i9-13900K on a fedora 40 distrobox with LLVM 15 on the PATH.

## Notes

- Benchmarks are run by mapping a noise function over a 1 million element unboxed array of indices.
  - This creates maybe ~1-2ms of overhead.
  - Using index tuples is intended to increase the probability that we hit as many possible code paths in the noise implementation. Some noise functions may skip certain computations when specific conditions are met relative to the input.
- Memory allocation should be constant.
  - Float ~= 4.0MB (4 bytes \* 1_000_000 elements)
  - Double ~= 8.0MB (8 bytes \* 1_000_000 elements)
- Benchmarks that use 'massiv' demonstrate thread-level parallelism, and are the intended path of use for most purposes as of now.

## `pure-noise` Results (LLVM)

Measured by values per second (vps) generated by the noise functions. These results are from benchmarks run with the `-fllvm` backend.

### 2D (Single-Thread)

| name          | Float (vps) | Double (vps) |
| :------------ | :---------- | :----------- |
| perlin2       | 150_184_296 | 158_927_257  |
| value2        | 149_517_446 | 156_863_684  |
| openSimplex2  | 73_271_710  | 74_653_530   |
| valueCubic2   | 60_116_124  | 51_553_169   |
| superSimplex2 | 49_809_654  | 50_437_097   |
| cellular2     | 34_909_269  | 31_798_924   |

### 3D (Single-Thread)

| name        | Float (vps) | Double (vps) |
| :---------- | :---------- | :----------- |
| value3      | 81_757_803  | 85_014_911   |
| perlin3     | 61_928_496  | 71_840_232   |
| valueCubic3 | 16_767_544  | 12_729_966   |

### 2D Parallel (`massiv`)

| name          | Float (vps)   | Double (vps)  |
| :------------ | :------------ | :------------ |
| value2        | 2_237_841_881 | 1_945_933_956 |
| perlin2       | 1_698_650_419 | 1_380_889_459 |
| openSimplex2  | 1_064_963_183 | 941_187_265   |
| valueCubic2   | 1_049_935_068 | 717_173_337   |
| superSimplex2 | 823_957_363   | 784_302_234   |
| cellular2     | 611_138_830   | 576_697_780   |

## Reproducibility

There are two hacky scripts in this folder that can be used to bench with the exact arguments I've used.

- `results/collect-bench.sh` -- hacky script to document the parameters used to create benchmark results
- `results/vps.py` -- _very_ hacky script to calculate values/second numbers from `tasty-bench` csv output

## Comparison with FastNoiseLite

To provide an accurate, hardware-equivalent comparison, benchmarks for [FastNoiseLite (FNL)](https://github.com/Auburn/FastNoiseLite) were run locally on the same machine using the `NoiseBenchmarking` tool and compared against this library's results (compiled with the LLVM backend).

### Benchmark Methodology

Two benchmark approaches are used:

1. **Standard benchmarks** (1M values): Use fractional coordinates with random offsets to exercise all code paths and avoid potential fast-path optimizations at integer boundaries
2. **FNL-comparison benchmarks** (262K values): Use integer-aligned grid coordinates matching FNL's exact methodology for direct apples-to-apples comparison. These benchmarks use `foldl'` with summation to prevent dead code elimination, matching FNL's `DoNotOptimize` approach. This adds ~2-5% overhead from coordinate tuple loading and floating-point addition, but provides a fairer comparison than materializing output vectors.

### Single-Thread Performance Comparison

**Direct comparison (integer-aligned grid, 512×512 for 2D, 64³ for 3D):**

| Noise Type          | pure-noise (Float) | FastNoiseLite | % of FNL |
| :------------------ | :----------------- | :------------ | :------- |
| **Cellular 2D**     | 67_835_683         | 71_874_200    | 94.4%    |
| **SuperSimplex 2D** | 97_260_597         | 106_499_000   | 91.3%    |
| **OpenSimplex2 2D** | 116_680_059        | 133_444_000   | 87.4%    |
| **Perlin 2D**       | 158_217_052        | 182_558_000   | 86.7%    |
| **ValueCubic 2D**   | 63_216_090         | 73_415_900    | 86.1%    |
| **Value 3D**        | 88_672_882         | 111_514_000   | 79.5%    |
| **Value 2D**        | 166_677_228        | 211_971_000   | 78.6%    |
| **ValueCubic 3D**   | 17_852_638         | 23_361_200    | 76.4%    |
| **Perlin 3D**       | 62_229_885         | 90_821_200    | 68.5%    |

Pure Haskell with LLVM achieves **68-94% of C++ performance** in single-threaded scenarios, with simpler noise types (Perlin, OpenSimplex2, SuperSimplex) reaching 86-94% of FNL's speed.

### Coordinate Pattern Impact

The choice of coordinate pattern affects performance differently across algorithms:

- **Cellular**: Integer coordinates provide +10-15% performance improvement over fractional coordinates. Distance-based algorithms benefit from simplified calculations and improved branch prediction at grid boundaries where cells align exactly.
- **OpenSimplex2/SuperSimplex**: Integer coordinates are significantly faster (+47% to +83%) than fractional, likely due to improved cache locality and branch prediction with regular grid patterns.
- **Perlin/Value/ValueCubic**: Integer coordinates are slightly slower (-1 to -2%) than fractional.

This variation demonstrates that different noise algorithms have fundamentally different performance characteristics depending on coordinate access patterns. The FNL comparison benchmarks use integer grids (matching FNL's methodology), while standard benchmarks use fractional coordinates (more representative of typical use cases).

### Parallel Performance

The `massiv`-based parallel benchmarks demonstrate significantly higher throughput by leveraging multiple cores. This is the intended path for high-performance, large-scale noise generation with this library.

For example, the parallel `massiv` 2D Perlin benchmark achieves **~1.7 billion values/sec**, over 10× the single-threaded FNL result and 12× the single-threaded pure-noise result.
