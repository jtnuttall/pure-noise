# pure-noise

Performant, modern noise generation for Haskell with a minimal dependency footprint.

The algorithms used in this library are ported from [FastNoiseLite](https://github.com/Auburn/FastNoiseLite). The library structure has been retuned to fit better with Haskell semantics.

The public interface for this library is unlikely to change much, although the implementations (`noiseBaseN` functions and anything in `Numeric.Noise.Internal`) are subject to change and may change between minor versions.

## Usage

The library exports newtypes for N-dimensional noise. Currently, these are just functions that accept a seed and a point in N-dimensional space. They can be arbitrarily unwrapped by with the `noiseNAt` family of functions. Since they abstract over the given seed and parameters, they can be composed with `Num` or `Fractional` methods at will with little-to-no performance cost.

Noise values are generally clamped to `[-1, 1]`, although some noise functions may occasionally produce values slightly outside this range.

```haskell
import Numeric.Noise qualified as Noise

myNoise2 :: (RealFrac a) => Seed -> a -> a -> a
myNoise2 =
  let fractalConfig = Noise.defaultFractalConfig
  in Noise.noise2At $
      Noise.fractal2 fractalConfig ((Noise.perlin2 + Noise.superSimplex2) / 2)
```

More examples can be found in `bench` and `demo`.

## Parallel noise generation

For large-scale noise generation, this library integrates well with [massiv](https://hackage.haskell.org/package/massiv) for parallel computation. Parallel performance can reach 10-12× single-threaded performance by leveraging multiple cores—for example, 2D Perlin noise generation achieves ~1.7 billion values/sec on an i9-13900K. This is the recommended approach for generating large noise textures or datasets.

## Performance notes

- This library benefits considerably from compilation with the LLVM backend (`-fllvm`). Benchmarks suggest a ~50-80% difference depending on the kind of noise.
- In single-threaded scenarios with LLVM enabled, this library achieves 68-94% of C++ FastNoiseLite performance, with simpler noise algorithms (Perlin, OpenSimplex2, SuperSimplex) reaching 86-94% of C++ speed.

## Benchmarks

### Results

Measured by values / second generated by the noise functions. These results come from a benchmark with `-fllvm` enabled.

There's inevitably some noise in the measurements because all of the results are forced into an unboxed vector.

#### 2D

| name          | Float (values/sec) | Double (values/sec) |
| ------------- | ------------------ | ------------------- |
| perlin2       | 150_184_296        | 158_927_257         |
| value2        | 149_517_446        | 156_863_684         |
| openSimplex2  | 73_271_710         | 74_653_530          |
| valueCubic2   | 60_116_124         | 51_553_169          |
| superSimplex2 | 49_809_654         | 50_437_097          |
| cellular2     | 34_909_269         | 31_798_924          |

#### 3D

| name        | Float (values/sec) | Double (values/sec) |
| ----------- | ------------------ | ------------------- |
| value3      | 81_757_803         | 85_014_911          |
| perlin3     | 61_928_496         | 71_840_232          |
| valueCubic3 | 16_767_544         | 12_729_966          |

## Examples

There's an interactive [demo app](https://github.com/jtnuttall/pure-noise/tree/main/demo) in the `demo` directory.

_OpenSimplex2_

![OpenSimplex2](https://raw.githubusercontent.com/jtnuttall/pure-noise/main/demo/images/opensimplex.png)
![OpenSimplex2 ridged](https://raw.githubusercontent.com/jtnuttall/pure-noise/main/demo/images/opensimplex-ridged.png)

_Perlin_

![Perlin fBm](https://raw.githubusercontent.com/jtnuttall/pure-noise/main/demo/images/perlin-fbm.png)

_Cellular_

![value](https://raw.githubusercontent.com/jtnuttall/pure-noise/main/demo/images/cell-value.png)
![distance2add](https://raw.githubusercontent.com/jtnuttall/pure-noise/main/demo/images/cell-d2.png)
